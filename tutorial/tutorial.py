# -*- coding: utf-8 -*-
"""tutorial.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1KK1XS7RD_lBkfd4hC5n80_lAE3mhhOLN
"""

#installing scanpy library
!pip install scanpy

#installing anndata library
!pip install anndata

#Importing Libraries
import sys
import scanpy as sc
import anndata
import pandas as pd
import numpy as np
import os
import gc

#Importing Libraries
import seaborn as sns
from matplotlib import pyplot as plt
import matplotlib as mpl

#Loading the data
sp_data_folder = '/content/drive/MyDrive/breastcancer'

#reading the visium data
adata = sc.read_visium(sp_data_folder, count_file='filtered_feature_bc_matrix.h5', load_images=True)

#Making adata variable names as unique
adata.var_names_make_unique()

#Checking the AnnData object
adata

#Making adata obs names as unique
adata.obs_names_make_unique()

#adata data shape
adata.X.shape

#Adata spatial shape checking
adata.obsm['spatial'].shape

#adata obsm checking
adata.obsm

#adata var names checking
adata.var_names

#adata var feature type checking
adata.var.feature_types

#Checking the adata obs that loaded from the csv
adata.obs

#Show those genes that yield the highest fraction of counts in each single cell, across all cells.
sc.pl.highest_expr_genes(adata, n_top=20,)

#Adding a new object to the anndata
adata.obs['thing'] = 'a'

#Plotting the adata with the new object
plt.rcParams["figure.figsize"] = (8, 8)
sc.pl.spatial(adata, color = 'thing')

#Checking whether the object added in the anndata obs
adata

#adata var table
adata.var

#checking adata obs to find out the new object
adata.obs

# Assembling some information about hemoglobin genes, which are important for quality control.
# With pp.calculate_qc_metrics, we can compute many metrics very efficiently.
adata.var['hb'] = adata.var_names.str.contains(("^HB[^(P)]"))
sc.pp.calculate_qc_metrics(adata, qc_vars=["hb"], inplace=True)

"""# Mitocondrial Genes are not in the Dataset. So checking the mitocondrial genes skipped in this step
#adata.var["mt"] = adata.var_names.str.startswith("MT-")
#sc.pp.calculate_qc_metrics(adata, qc_vars=["mt"], inplace=True)

# Ribo Genes are not in the Dataset. So skipped in this process
# adata.var['ribo'] = adata.var_names.str.startswith(("RPS","RPL"))
# sc.pp.calculate_qc_metrics(adata, qc_vars=["ribo"], inplace=True)
"""

#Checking the adata obs with the updated metrics from the hemoglobin genes
adata.obs

#Based on the updated genes from hemoglobin genes metrics, four different shaped bar plots here to understand the genes.
fig, axs = plt.subplots(1, 4, figsize=(15, 4))
sns.distplot(adata.obs["total_counts"], kde=False, ax=axs[0])
sns.distplot(adata.obs["total_counts"][adata.obs["total_counts"] < 10000], kde=False, bins=40, ax=axs[1])
sns.distplot(adata.obs["n_genes_by_counts"], kde=False, bins=60, ax=axs[2])
sns.distplot(adata.obs["n_genes_by_counts"][adata.obs["n_genes_by_counts"] < 4000], kde=False, bins=60, ax=axs[3])
plt.show()

#Plotting the total_genes less than 2000
sns.distplot(adata.obs["total_counts"][adata.obs["total_counts"] < 2000], kde=False, bins=40)

#filtering adata with min and max
sc.pp.filter_cells(adata, min_counts = 1000)

sc.pp.filter_cells(adata, max_counts=35000)

#Violin plotting of the pct_counts_hb
sc.pl.violin(adata, ['pct_counts_hb'], jitter=0.4)

#Violin plotting of the total genes and pct_counts_hb
sc.pl.violin(
    adata,
    [
     'n_genes_by_counts',
     'total_counts',
     'pct_counts_hb'
     ],
    multi_panel=True
)

#Plotting the pct_counts_hb in to see the hemoglobin genes expression or total counts
p3 = sc.pl.scatter(adata, "total_counts", "n_genes_by_counts", color="pct_counts_hb")

#Filtering adata based on the value of the pct_counts_hb >=0.001 and updated the adata with new shaped genes
adata = adata[adata.obs["pct_counts_hb"] >= 0.001]

sc.pp.filter_genes(adata, min_cells=3)

#checking adata objects
adata

#Plotting the adata with the thing object to see whether the genes are reduced
plt.rcParams["figure.figsize"] = (8, 8)
sc.pl.spatial(adata, color = 'thing')

#adata var cell counts
adata.var['n_cells_by_counts']

#Using the log1p checking the adata's highly variable genes
sc.pp.normalize_total(adata, inplace=True)
sc.pp.log1p(adata)
sc.pp.highly_variable_genes(adata, flavor="seurat", n_top_genes=2000)

#Plotthing adata highly variable and other genes
sc.pl.highly_variable_genes(adata, log=True)

"""#Leiden"""

#Installing leiden
!pip install leidenalg

#Principal Component Analysis of the adata
sc.pp.pca(adata)
#compute the neighborhood graph of cells using the PCA representation of the adata matrix
sc.pp.neighbors(adata)
#embedding the graph in two dimensions using UMAP
sc.tl.umap(adata)
#Plot the clusters, Leiden clustering directly clusters the neighborhood graph of cells.
sc.tl.leiden(adata)

#Plotting the clusters of Leiden Algorithms
plt.rcParams["figure.figsize"] = (4, 4)
sc.pl.umap(adata, color=["total_counts", "n_genes_by_counts", "leiden"], wspace=0.4)

#importing libraries
from matplotlib.pyplot import rc_context

#With rc_context plotting the clustering of cells using Leiden
with rc_context({'figure.figsize': (5, 5)}):
    sc.pl.umap(adata, color='leiden', add_outline=True, legend_loc='on data',
               legend_fontsize=12, legend_fontoutline=2,frameon=False,
               title='clustering of cells', palette='Set1')

#Creating new adata with the leiden clustering for marker genes
adata2 = adata

#Using the wilcoxon method and leiden finding out the marker genes from adata
sc.tl.rank_genes_groups(adata2, 'leiden', method='wilcoxon')

#Coverting the dataframe with matrices to find out the marker genes
resultsLD = adata2.uns['rank_genes_groups']
('0', '1', '2', '3', '4')

outLD = np.array([[0,0,0,0,0]])
for group in resultsLD['names'].dtype.names:
    outLD = np.vstack((outLD, np.vstack((resultsLD['names'][group],
                                     resultsLD['scores'][group],
                                     resultsLD['pvals_adj'][group],
                                     resultsLD['logfoldchanges'][group],
                                     np.array([group] * len(resultsLD['names'][group])).astype('object'))).T))



markersLD = pd.DataFrame(outLD[1:], columns = ['Gene', 'scores', 'pval_adj', 'lfc', 'cluster'])

markersLD = markersLD[(markersLD.pval_adj < 0.05) & (abs(markersLD.lfc) > 1)]

#Printing the marker genes from leiden
markersLD

#Checking the total number of marker genes per group using Leiden
pd.DataFrame(adata2.uns['rank_genes_groups']['names']).head(20000)

"""#Louvain"""

#Installing louvain
!pip install louvain

#Principal Component Analysis of the adata
sc.pp.pca(adata)
#compute the neighborhood graph of cells using the PCA representation of the adata matrix
sc.pp.neighbors(adata)
#embedding the graph in two dimensions using UMAP
sc.tl.umap(adata)
#Plot the clusters, Louvain clustering directly clusters the neighborhood graph of cells.
sc.tl.louvain(adata)

#Plotting the clusters of Louvain Algorithms
plt.rcParams["figure.figsize"] = (4, 4)
sc.pl.umap(adata, color=["total_counts", "n_genes_by_counts", "louvain"], wspace=0.4)

#With rc_context plotting the clustering of cells using Louvain
with rc_context({'figure.figsize': (5, 5)}):
    sc.pl.umap(adata, color='louvain', add_outline=True, legend_loc='on data',
               legend_fontsize=12, legend_fontoutline=2,frameon=False,
               title='clustering of cells', palette='Set1')

#Creating new adata with the louvain clustering for marker genes
adata3=adata

#Using the wilcoxon method and leiden finding out the marker genes from adata
sc.tl.rank_genes_groups(adata3, 'louvain', method='wilcoxon')

#Coverting the dataframe with matrices to find out the marker genes
resultsLO = adata.uns['rank_genes_groups']
('0', '1', '2', '3', '4')

outLO = np.array([[0,0,0,0,0]])
for group in resultsLO['names'].dtype.names:
    outLO = np.vstack((outLO, np.vstack((resultsLO['names'][group],
                                     resultsLO['scores'][group],
                                     resultsLO['pvals_adj'][group],
                                     resultsLO['logfoldchanges'][group],
                                     np.array([group] * len(resultsLO['names'][group])).astype('object'))).T))



markersLO = pd.DataFrame(outLO[1:], columns = ['Gene', 'scores', 'pval_adj', 'lfc', 'cluster'])

markersLO = markersLO[(markersLO.pval_adj < 0.05) & (abs(markersLO.lfc) > 1)]

#Printing the marker genes from louvain
markersLO

#Checking the total number of marker genes per group using Louvain
pd.DataFrame(adata3.uns['rank_genes_groups']['names']).head(20000)

"""#K-means"""

#Importing k-means libraries
from sklearn.cluster import KMeans
from sklearn.metrics import adjusted_rand_score

# extract pca coordinates
X_pca = adata.obsm['X_pca']

#Training the pca components of the data and adding to the dataset
kmeans = KMeans(n_clusters=10, random_state=0).fit(X_pca)
adata.obs['kmeans'] = kmeans.labels_.astype(str)

#Plotting the clusters of k-means Algorithms
plt.rcParams["figure.figsize"] = (4, 4)
sc.pl.umap(adata, color=["total_counts", "n_genes_by_counts", "kmeans"], wspace=0.4)

#With rc_context plotting the clustering of cells using kmeans
with rc_context({'figure.figsize': (5, 5)}):
    sc.pl.umap(adata, color='kmeans', add_outline=True, legend_loc='on data',
               legend_fontsize=12, legend_fontoutline=2,frameon=False,
               title='clustering of cells', palette='Set1')

#Creating new adata with the kmeans clustering for marker genes
adata4 = adata

#Using the wilcoxon method and leiden finding out the marker genes from adata
sc.tl.rank_genes_groups(adata4, 'kmeans', method='wilcoxon')

#Coverting the dataframe with matrices to find out the marker genes
resultsKM = adata4.uns['rank_genes_groups']
('0', '1', '2', '3', '4')

outKM = np.array([[0,0,0,0,0]])
for group in resultsKM['names'].dtype.names:
    outKM = np.vstack((outKM, np.vstack((resultsKM['names'][group],
                                     resultsKM['scores'][group],
                                     resultsKM['pvals_adj'][group],
                                     resultsKM['logfoldchanges'][group],
                                     np.array([group] * len(resultsKM['names'][group])).astype('object'))).T))



markersKM = pd.DataFrame(outKM[1:], columns = ['Gene', 'scores', 'pval_adj', 'lfc', 'cluster'])

markersKM = markersKM[(markersKM.pval_adj < 0.05) & (abs(markersKM.lfc) > 1)]

#Printing the marker genes from louvain
markersKM

#Checking the total number of marker genes per group using Louvain
pd.DataFrame(adata4.uns['rank_genes_groups']['names']).head(20000)

"""#HClust"""

#Importing Hierarchical Cluster Analysis libraries
from sklearn.cluster import AgglomerativeClustering

#Training the pca components of the data and adding to the dataset
cluster = AgglomerativeClustering(n_clusters=10, affinity='euclidean', linkage='ward')
adata.obs['hclust_10'] = cluster.fit_predict(X_pca).astype(str)

#Plotting the clusters of h-clust Algorithms
plt.rcParams["figure.figsize"] = (4, 4)
sc.pl.umap(adata, color=["total_counts", "n_genes_by_counts", "hclust_10"], wspace=0.4)

#With rc_context plotting the clustering of cells using hclust
with rc_context({'figure.figsize': (5, 5)}):
    sc.pl.umap(adata, color='hclust_10', add_outline=True, legend_loc='on data',
               legend_fontsize=12, legend_fontoutline=2,frameon=False,
               title='clustering of cells', palette='Set1')

#Creating new adata with the hclust clustering for marker genes
adata5 = adata

#Using the wilcoxon method and hclust finding out the marker genes from adata
sc.tl.rank_genes_groups(adata5, 'hclust_10', method='wilcoxon')

#Coverting the dataframe with matrices to find out the marker genes
resultsHC = adata5.uns['rank_genes_groups']
('0', '1', '2', '3', '4')

outHC = np.array([[0,0,0,0,0]])
for group in resultsHC['names'].dtype.names:
    outHC = np.vstack((outHC, np.vstack((resultsHC['names'][group],
                                     resultsHC['scores'][group],
                                     resultsHC['pvals_adj'][group],
                                     resultsHC['logfoldchanges'][group],
                                     np.array([group] * len(resultsHC['names'][group])).astype('object'))).T))



markersHC = pd.DataFrame(outHC[1:], columns = ['Gene', 'scores', 'pval_adj', 'lfc', 'cluster'])

markersHC = markersHC[(markersHC.pval_adj < 0.05) & (abs(markersHC.lfc) > 1)]

#Printing the marker genes from hclust
markersHC

#Checking the total number of marker genes per group using hclust
pd.DataFrame(adata5.uns['rank_genes_groups']['names']).head(20000)

"""#Squidypy"""

#Installing Squidpy
!pip install squidpy

#Importing squidpy libraries
import scanpy as sc
import squidpy as sq

sc.settings.verbosity = 3
sc.settings.set_figure_params(dpi=80, facecolor="white")

# nearest neighbor graph
sc.pp.neighbors(adata)
nn_graph_genes = adata.obsp["connectivities"]
# spatial proximity graph
sq.gr.spatial_neighbors(adata)
nn_graph_space = adata.obsp["spatial_connectivities"]

#adding the two graphs and compute leiden on the joint graph
#weight the importance of each graph based on an hyperparameters alpha
alpha = 0.2
joint_graph = (1 - alpha) * nn_graph_genes + alpha * nn_graph_space
sc.tl.leiden(adata, adjacency=joint_graph, key_added="squidpy_domains")

##Plotting the adata with Squidpy
sq.pl.spatial_scatter(adata, color=["squidpy_domains"], wspace=0.9)

#Plotting the clusters of Squidpy Algorithm
with rc_context({'figure.figsize': (5, 5)}):
    sc.pl.umap(adata, color='squidpy_domains', add_outline=True, legend_loc='on data',
               legend_fontsize=12, legend_fontoutline=2,frameon=False,
               title='clustering of cells', palette='Set1')

#Creating new adata with the squidpy for marker genes
adata6 = adata

#Using the wilcoxon method and squidpy to finding out the marker genes from adata
sc.tl.rank_genes_groups(adata6, 'squidpy_domains', method='wilcoxon')

#Coverting the dataframe with matrices to find out the marker genes
resultsSP = adata6.uns['rank_genes_groups']
('0', '1', '2', '3', '4')

outSP = np.array([[0,0,0,0,0]])
for group in resultsSP['names'].dtype.names:
    outSP = np.vstack((outSP, np.vstack((resultsSP['names'][group],
                                     resultsSP['scores'][group],
                                     resultsSP['pvals_adj'][group],
                                     resultsSP['logfoldchanges'][group],
                                     np.array([group] * len(resultsSP['names'][group])).astype('object'))).T))



markersSP = pd.DataFrame(outSP[1:], columns = ['Gene', 'scores', 'pval_adj', 'lfc', 'cluster'])

markersSP = markersSP[(markersSP.pval_adj < 0.05) & (abs(markersSP.lfc) > 1)]

#Printing the marker genes from squidpy
markersSP

#Checking the total number of marker genes per group using squidpy
pd.DataFrame(adata6.uns['rank_genes_groups']['names']).head(20000)

"""#SpaGCN"""

#Installing spaGCN
!pip install SpaGCN

#Importing libraries
import PIL

#defining pixel values of the histological image of the spatial dataset
PIL.Image.MAX_IMAGE_PIXELS = 933120000

#Importing libraries
import SpaGCN as spg
from PIL import Image
import requests

#creating an array with the image pixel
img = np.asarray(
    Image.open(
            "/content/drive/MyDrive/breastcancer/Visium_FFPE_Human_Breast_Cancer_image.tif",
    )
)

#Creating new adata
adata7=adata

#Setting the coordinates
x_array = adata7.obs["array_row"].tolist()
y_array = adata7.obs["array_col"].tolist()
x_pixel = (adata7.obsm["spatial"][:, 0]).tolist()
y_pixel = adata7.obsm["spatial"][:, 1].tolist()

#Calculating the adjacent matrix
adj = spg.calculate_adj_matrix(
    x=x_pixel,
    y=y_pixel,
    x_pixel=x_pixel,
    y_pixel=y_pixel,
    image=img,
    beta=55,
    alpha=1,
    histology=True,
)

#making the var names unique for the new data
adata7.var_names_make_unique()

#filtering the spatial genes with cell=5
sc.pp.filter_genes(adata7, min_cells=5)

#finding mitochondrial (MT) genes though the dataset doesn't have any
adata.var["MT_gene"] = [gene.startswith("MT-") for gene in adata.var_names]
#removing MT genes (keeping their counts in the object)
adata.obsm["MT"] = adata[:, adata.var["MT_gene"].values].X.toarray()
adata = adata[:, ~adata.var["MT_gene"].values].copy()

#Normalizing and taking log for UMI
sc.pp.normalize_total(adata7)
sc.pp.log1p(adata7)

p = 0.5
#Finding the l value given p
l = spg.search_l(p, adj)

#Searching for suitable resolution
res = spg.search_res(adata7, adj, l, target_num=15)

#setting up spaGCN model
model = spg.SpaGCN()
model.set_l(l)

#Training the model
model.train(adata7, adj, res=res)

#Predicting using the model
y_pred, prob = model.predict()

#adding the new spaGCN domain to the anndata
adata7.obs["spaGCN_domains"] = y_pred
adata7.obs["spaGCN_domains"] = adata7.obs["spaGCN_domains"].astype("category")

#plotting the spaGCN domain
sq.pl.spatial_scatter(adata7, color=["spaGCN_domains"])

#Calculateing adj matrix using xy only
adj_2d = spg.calculate_adj_matrix(x=x_array, y=y_array, histology=False)

#Creating a category of in the anndata
adata7.obs["spaGCN_domains"] = adata7.obs["spaGCN_domains"].astype(
    "category"
)

#replotting the spaGCN domain
sq.pl.spatial_scatter(adata7, color=["spaGCN_domains"])

#Principal Component Analysis of the adata
sc.pp.pca(adata7)
#compute the neighborhood graph of cells using the PCA representation of the adata matrix
sc.pp.neighbors(adata7)
#embedding the graph in two dimensions using UMAP
sc.tl.umap(adata7)

#Plotting the clusters of spaGCN Algorithms
plt.rcParams["figure.figsize"] = (4, 4)
sc.pl.umap(adata7, color=["total_counts", "n_genes_by_counts", "spaGCN_domains"], wspace=0.4)

#Plotting the clusters of spaGCN Algorithm
with rc_context({'figure.figsize': (5, 5)}):
    sc.pl.umap(adata7, color='spaGCN_domains', add_outline=True, legend_loc='on data',
               legend_fontsize=12, legend_fontoutline=2,frameon=False,
               title='clustering of cells', palette='Set1')

#Using the wilcoxon method and spaGCN to finding out the marker genes from adata
sc.tl.rank_genes_groups(adata7, 'spaGCN_domains', method='wilcoxon')

#Coverting the dataframe with matrices to find out the marker genes
resultsSPG = adata7.uns['rank_genes_groups']
('0', '1', '2', '3', '4')

outSPG = np.array([[0,0,0,0,0]])
for group in resultsSPG['names'].dtype.names:
    outSPG = np.vstack((outSPG, np.vstack((resultsSPG['names'][group],
                                     resultsSPG['scores'][group],
                                     resultsSPG['pvals_adj'][group],
                                     resultsSPG['logfoldchanges'][group],
                                     np.array([group] * len(resultsSPG['names'][group])).astype('object'))).T))



markersSPG = pd.DataFrame(outSPG[1:], columns = ['Gene', 'scores', 'pval_adj', 'lfc', 'cluster'])

markersSPG = markersSPG[(markersSPG.pval_adj < 0.05) & (abs(markersSPG.lfc) > 1)]

#Printing the marker genes from spaGCN
markersSPG

#Checking the total number of marker genes per group using spaGCN
pd.DataFrame(adata7.uns['rank_genes_groups']['names']).head(20000)

#visualizing clustered samples in spatial dimensions using Leiden
sc.pl.spatial(adata, img_key="hires", color="leiden", size=1.5)

#visualizing clustered samples in spatial dimensions using louvain
sc.pl.spatial(adata, img_key="hires", color="louvain", size=1.5)

#visualizing clustered samples in spatial dimensions using kmeans
sc.pl.spatial(adata, img_key="hires", color="kmeans", size=1.5)

#visualizing clustered samples in spatial dimensions using hclust
sc.pl.spatial(adata, img_key="hires", color="hclust_10", size=1.5)

#visualizing clustered samples in spatial dimensions using squidpy
sc.pl.spatial(adata, img_key="hires", color="squidpy_domains", size=1.5)

#visualizing clustered samples in spatial dimensions using spaGCN
sc.pl.spatial(adata, img_key="hires", color="spaGCN_domains", size=1.5)